/*
 Copyright 2021 Crunchy Data Solutions, Inc.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

package patroni

import (
	"fmt"

	v1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"sigs.k8s.io/yaml"

	"github.com/crunchydata/postgres-operator/internal/naming"
	"github.com/crunchydata/postgres-operator/pkg/apis/postgres-operator.crunchydata.com/v1alpha1"
)

const (
	configDirectory  = "/etc/patroni"
	configMapFileKey = "patroni.yaml"
)

const (
	yamlGeneratedWarning = "" +
		"# Generated by postgres-operator. DO NOT EDIT.\n" +
		"# Your changes will not be saved.\n"
)

// clusterConfigMap populates cm with Patroni settings for cluster.
func clusterConfigMap(cluster *v1alpha1.PostgresCluster, cm *v1.ConfigMap) error {
	if cm.Data == nil {
		cm.Data = make(map[string]string)
	}

	var err error
	cm.Data[configMapFileKey], err = clusterYAML(cluster)

	return err
}

// clusterYAML returns Patroni settings that apply to the entire cluster.
func clusterYAML(cluster *v1alpha1.PostgresCluster) (string, error) {
	root := map[string]interface{}{
		// The cluster identifier. This value cannot change during the cluster's
		// lifetime.
		"scope": cluster.Name,

		// Use Kubernetes Endpoints for the distributed configuration store (DCS).
		// These values cannot change during the cluster's lifetime.
		//
		// NOTE(cbandy): It *might* be possible to *carefully* change the role and
		// scope labels, but there is no way to reconfigure all instances at once.
		"kubernetes": map[string]interface{}{
			"namespace":     cluster.Namespace,
			"role_label":    naming.LabelRole,
			"scope_label":   naming.LabelCluster,
			"use_endpoints": true,

			// In addition to "scope_label" above, Patroni will add the following to
			// every object it creates. It will also use these as filters when doing
			// any lookups.
			"labels": map[string]string{},
		},

		"postgresql": map[string]interface{}{
			"authentication": map[string]interface{}{
				// TODO(cbandy): "superuser"
				// TODO(cbandy): "replication"
			},

			// TODO(cbandy): "callbacks"

			// When it is enabled, use pgBackRest to create replicas.
			//
			// NOTE(cbandy): Very few environment variables are set. This might belong
			// in the instance configuration because of the data directory.
			// NOTE(cbandy): Is there any chance a user might want to specify their own
			// method? This is a list and cannot be merged.
			"create_replica_methods": []string{},

			// Custom configuration "must exist on all cluster nodes".
			//
			// TODO(cbandy): I imagine we will always set this to a file we own. At
			// the very least, it will start with an "include_dir" directive.
			// - https://www.postgresql.org/docs/current/config-setting.html#CONFIG-INCLUDES
			//"custom_conf": nil,

			// TODO(cbandy): Should "parameters", "pg_hba", and "pg_ident" be set in
			// DCS? If so, are they are automatically regenerated and reloaded?
		},

		// NOTE(cbandy): Every Patroni instance is a client of every other Patroni
		// instance. TLS and/or authentication settings need to be applied consistently
		// across the entire cluster. Those settings belong here, in the "restapi" section.
	}

	b, err := yaml.Marshal(root)
	return string(append([]byte(yamlGeneratedWarning), b...)), err
}

// instanceConfigMap populates cm with Patroni settings for instance.
func instanceConfigMap(
	cluster *v1alpha1.PostgresCluster, instance metav1.Object, cm *v1.ConfigMap,
) error {
	if cm.Data == nil {
		cm.Data = make(map[string]string)
	}

	var err error
	cm.Data[configMapFileKey], err = instanceYAML(cluster, instance)

	return err
}

// instanceEnvVars populates pod with Patroni settings for an instance.
func instanceEnvVars(_ *v1alpha1.PostgresCluster, pod *v1.PodSpec) {
	// TODO(cbandy): Ports will come from the spec.
	var (
		patroniPort  = 8008
		postgresPort = 5432
	)

	// TODO(cbandy): This must match the primary Service definition:
	// ServicePort(name, targetPort, protocol) â†’ EndpointPort(name, port, protocol)
	ports, _ := yaml.Marshal([]v1.EndpointPort{})

	expected := []v1.EnvVar{
		// Set "name" to the v1.Pod's name. Required when using Kubernetes for DCS.
		// Patroni must be restarted when changing this value.
		{
			Name: "PATRONI_NAME",
			ValueFrom: &v1.EnvVarSource{FieldRef: &v1.ObjectFieldSelector{
				APIVersion: "v1",
				FieldPath:  "metadata.name",
			}},
		},

		// Set "kubernetes.pod_ip" to the v1.Pod's primary IP address.
		// Patroni must be restarted when changing this value.
		{
			Name: "PATRONI_KUBERNETES_POD_IP",
			ValueFrom: &v1.EnvVarSource{FieldRef: &v1.ObjectFieldSelector{
				APIVersion: "v1",
				FieldPath:  "status.podIP",
			}},
		},

		// When using Endpoints for DCS, Patroni needs to replicate the ServicePort
		// definitions exactly.
		// The PostgreSQL port can differ between instances so long as the primary
		// Service uses a named (not numeric) targetPort.
		// TODO(cbandy): Combine the above statements accurately.
		//
		// This is connascent with PATRONI_POSTGRESQL_CONNECT_ADDRESS below.
		// Patroni must be restarted when changing this value.
		{
			Name:  "PATRONI_KUBERNETES_PORTS",
			Value: string(ports),
		},

		// Set "postgresql.connect_address" using the IP address from above.
		// PostgreSQL must be restarted when changing this value.
		{
			Name:  "PATRONI_POSTGRESQL_CONNECT_ADDRESS",
			Value: fmt.Sprintf("%s:%d", "$(PATRONI_KUBERNETES_POD_IP)", postgresPort),
		},

		// Set "postgresql.listen" using the special address "*" to mean all TCP
		// interfaces. When connecting locally over TCP, Patroni will use "localhost".
		//
		// This is connascent with PATRONI_POSTGRESQL_CONNECT_ADDRESS above.
		// PostgreSQL must be restarted when changing this value.
		{
			Name:  "PATRONI_POSTGRESQL_LISTEN",
			Value: fmt.Sprintf("*:%d", postgresPort),
		},

		// Set "restapi.connect_address" using the IP address from above.
		// Patroni must be reloaded when changing this value.
		{
			Name:  "PATRONI_RESTAPI_CONNECT_ADDRESS",
			Value: fmt.Sprintf("%s:%d", "$(PATRONI_KUBERNETES_POD_IP)", patroniPort),
		},

		// Set "restapi.listen" using the special address "*" to mean all TCP interfaces.
		// This is connascent with PATRONI_RESTAPI_CONNECT_ADDRESS above.
		// Patroni must be reloaded when changing this value.
		{
			Name:  "PATRONI_RESTAPI_LISTEN",
			Value: fmt.Sprintf("*:%d", patroniPort),
		},

		// Our image tells the Patroni daemon `patroni` to look here for its
		// configuration file(s).
		// TODO(cbandy): Make this true!
		{
			Name:  "PATRONI_CONFIG_FILE",
			Value: configDirectory,
		},

		// The Patroni client `patronictl` looks here for its configuration file(s).
		{
			Name:  "PATRONICTL_CONFIG_FILE",
			Value: configDirectory,
		},
	}

	database := findOrAppendContainer(&pod.Containers, "database")
	database.Env = mergeEnvVars(database.Env, expected...)
}

// instanceConfigVolumeAndMount populates pod with a volume and mount of
// clusterConfigMap and instanceConfigMap.
func instanceConfigVolumeAndMount(
	_ *v1alpha1.PostgresCluster, clusterConfigMap, instanceConfigMap *v1.ConfigMap,
	pod *v1.PodSpec,
) {
	// TODO(cbandy): User config will come from the spec.
	var (
		patroniConfig []v1.VolumeProjection
	)

	volume := v1.Volume{Name: "patroni-config"}
	volume.Projected = &v1.ProjectedVolumeSource{}

	// Add our projections after those specified in the CR. Items later in the
	// list take precedence over earlier items (that is, last write wins).
	// - https://docs.openshift.com/container-platform/latest/nodes/containers/nodes-containers-projected-volumes.html
	// - https://kubernetes.io/docs/concepts/storage/volumes/#projected
	volume.Projected.Sources = append(
		patroniConfig,
		v1.VolumeProjection{
			ConfigMap: &v1.ConfigMapProjection{
				LocalObjectReference: v1.LocalObjectReference{
					Name: clusterConfigMap.Name,
				},
				Items: []v1.KeyToPath{{
					Key:  configMapFileKey,
					Path: "~postgres-operator_cluster.yaml",
				}},
			},
		},
		v1.VolumeProjection{
			ConfigMap: &v1.ConfigMapProjection{
				LocalObjectReference: v1.LocalObjectReference{
					Name: instanceConfigMap.Name,
				},
				Items: []v1.KeyToPath{{
					Key:  configMapFileKey,
					Path: "~postgres-operator_instance.yaml",
				}},
			},
		},
	)

	mount := v1.VolumeMount{
		Name:      volume.Name,
		MountPath: configDirectory,
		ReadOnly:  true,
	}

	pod.Volumes = mergeVolumes(pod.Volumes, volume)

	database := findOrAppendContainer(&pod.Containers, "database")
	database.VolumeMounts = mergeVolumeMounts(database.VolumeMounts, mount)
}

// instanceYAML returns Patroni settings that apply to instance.
func instanceYAML(_ *v1alpha1.PostgresCluster, _ metav1.Object) (string, error) {
	root := map[string]interface{}{
		// Missing here is "name" which cannot be known until the instance Pod is
		// created. That value should be injected using the downward API and the
		// PATRONI_NAME environment variable.

		"kubernetes": map[string]interface{}{
			// Missing here is "pod_ip" which cannot be known until the instance Pod is
			// created. That value should be injected using the downward API and the
			// PATRONI_KUBERNETES_POD_IP environment variable.

			// Missing here is "ports" which is is connascent with "postgresql.connect_address".
			// See the PATRONI_KUBERNETES_PORTS env variable.
		},

		"postgresql": map[string]interface{}{
			// TODO(cbandy): "bin_dir"
			// TODO(cbandy): "config_dir" so that users cannot override.

			// Missing here is "connect_address" which cannot be known until the
			// instance Pod is created. That value should be injected using the downward
			// API and the PATRONI_POSTGRESQL_CONNECT_ADDRESS environment variable.

			// TODO(cbandy): "data_dir"

			// Missing here is "listen" which is connascent with "connect_address".
			// See the PATRONI_POSTGRESQL_LISTEN environment variable.

			// TODO(cbandy): "pgpass"

			// Prefer to use UNIX domain sockets for local connections. If the PostgreSQL
			// parameter "unix_socket_directories" is set, Patroni will connect using one
			// of those directories. Otherwise, it will use the client (libpq) default.
			"use_unix_socket": true,
		},

		"restapi": map[string]interface{}{
			// Missing here is "connect_address" which cannot be known until the
			// instance Pod is created. That value should be injected using the downward
			// API and the PATRONI_RESTAPI_CONNECT_ADDRESS environment variable.

			// Missing here is "listen" which is connascent with "connect_address".
			// See the PATRONI_RESTAPI_LISTEN environment variable.
		},

		"tags": map[string]interface{}{
			// TODO(cbandy): "nofailover"
			// TODO(cbandy): "nosync"
		},
	}

	b, err := yaml.Marshal(root)
	return string(append([]byte(yamlGeneratedWarning), b...)), err
}
