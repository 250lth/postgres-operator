/*
 Copyright 2021 Crunchy Data Solutions, Inc.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

package patroni

import (
	"encoding/json"
	"fmt"

	"github.com/pkg/errors"
	v1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"sigs.k8s.io/yaml"

	"github.com/crunchydata/postgres-operator/internal/naming"
	"github.com/crunchydata/postgres-operator/internal/postgres"
	"github.com/crunchydata/postgres-operator/pkg/apis/postgres-operator.crunchydata.com/v1alpha1"
)

const (
	configDirectory  = "/etc/patroni"
	configMapFileKey = "patroni.yaml"
)

const (
	yamlGeneratedWarning = "" +
		"# Generated by postgres-operator. DO NOT EDIT.\n" +
		"# Your changes will not be saved.\n"
)

// clusterConfigMap populates cm with Patroni settings for cluster.
func clusterConfigMap(cluster *v1alpha1.PostgresCluster, cm *v1.ConfigMap) error {
	if cm.Data == nil {
		cm.Data = make(map[string]string)
	}

	var err error
	cm.Data[configMapFileKey], err = clusterYAML(cluster)

	return err
}

// clusterYAML returns Patroni settings that apply to the entire cluster.
func clusterYAML(cluster *v1alpha1.PostgresCluster) (string, error) {
	root := map[string]interface{}{
		// The cluster identifier. This value cannot change during the cluster's
		// lifetime.
		"scope": naming.PatroniScope(cluster),

		// FIXME(cbandy): bootstrap.dcs is required to actually bootstrap.
		"bootstrap": map[string]interface{}{
			"dcs": map[string]interface{}{},
		},

		// Use Kubernetes Endpoints for the distributed configuration store (DCS).
		// These values cannot change during the cluster's lifetime.
		//
		// NOTE(cbandy): It *might* be possible to *carefully* change the role and
		// scope labels, but there is no way to reconfigure all instances at once.
		"kubernetes": map[string]interface{}{
			"namespace":     cluster.Namespace,
			"role_label":    naming.LabelRole,
			"scope_label":   naming.LabelPatroni,
			"use_endpoints": true,

			// In addition to "scope_label" above, Patroni will add the following to
			// every object it creates. It will also use these as filters when doing
			// any lookups.
			"labels": map[string]string{
				naming.LabelCluster: cluster.Name,
			},
		},

		"postgresql": map[string]interface{}{
			"authentication": map[string]interface{}{
				// TODO(cbandy): "superuser"
				// FIXME(cbandy): "replication"
				"replication": map[string]interface{}{
					"username": "postgres",
				},
			},

			// TODO(cbandy): "callbacks"

			// When it is enabled, use pgBackRest to create replicas.
			//
			// NOTE(cbandy): Very few environment variables are set. This might belong
			// in the instance configuration because of the data directory.
			// NOTE(cbandy): Is there any chance a user might want to specify their own
			// method? This is a list and cannot be merged.
			"create_replica_methods": []string{},

			// Custom configuration "must exist on all cluster nodes".
			//
			// TODO(cbandy): I imagine we will always set this to a file we own. At
			// the very least, it will start with an "include_dir" directive.
			// - https://www.postgresql.org/docs/current/config-setting.html#CONFIG-INCLUDES
			//"custom_conf": nil,

			// TODO(cbandy): Should "parameters", "pg_hba", and "pg_ident" be set in
			// DCS? If so, are they are automatically regenerated and reloaded?
		},

		// NOTE(cbandy): Every Patroni instance is a client of every other Patroni
		// instance. TLS and/or authentication settings need to be applied consistently
		// across the entire cluster. Those settings belong here, in the "restapi" section.
	}

	b, err := yaml.Marshal(root)
	return string(append([]byte(yamlGeneratedWarning), b...)), err
}

// DynamicConfiguration combines configuration with some PostgreSQL settings
// and returns a value that can be marshaled to JSON.
func DynamicConfiguration(
	configuration map[string]interface{},
	pgHBAs postgres.HBAs, pgParameters postgres.Parameters,
) map[string]interface{} {
	// Copy the entire configuration before making any changes.
	root := make(map[string]interface{}, len(configuration))
	for k, v := range configuration {
		root[k] = v
	}

	// Copy the "postgresql" section before making any changes.
	postgresql := make(map[string]interface{})
	if section, ok := root["postgresql"].(map[string]interface{}); ok {
		for k, v := range section {
			postgresql[k] = v
		}
	}
	root["postgresql"] = postgresql

	// Copy the "postgresql.parameters" section over any defaults.
	parameters := make(map[string]interface{})
	if pgParameters.Default != nil {
		for k, v := range pgParameters.Default.AsMap() {
			parameters[k] = v
		}
	}
	if section, ok := postgresql["parameters"].(map[string]interface{}); ok {
		for k, v := range section {
			parameters[k] = v
		}
	}
	// Override the above with mandatory parameters.
	if pgParameters.Mandatory != nil {
		for k, v := range pgParameters.Mandatory.AsMap() {
			parameters[k] = v
		}
	}
	postgresql["parameters"] = parameters

	// Copy the "postgresql.pg_hba" section after any mandatory values.
	hba := make([]string, len(pgHBAs.Mandatory))
	for i := range pgHBAs.Mandatory {
		hba[i] = pgHBAs.Mandatory[i].String()
	}
	if section, ok := postgresql["pg_hba"].([]string); ok {
		hba = append(hba, section...)
	}
	// When the section is missing or empty, include the recommended defaults.
	if len(hba) == len(pgHBAs.Mandatory) {
		for i := range pgHBAs.Default {
			hba = append(hba, pgHBAs.Default[i].String())
		}
	}
	postgresql["pg_hba"] = hba

	// TODO(cbandy): explain this.
	postgresql["use_pg_rewind"] = true

	return root
}

// instanceConfigMap populates cm with Patroni settings for instance.
func instanceConfigMap(
	cluster *v1alpha1.PostgresCluster, instance metav1.Object, cm *v1.ConfigMap,
) error {
	if cm.Data == nil {
		cm.Data = make(map[string]string)
	}

	var err error
	cm.Data[configMapFileKey], err = instanceYAML(cluster, instance)

	return err
}

// instanceEnvVars populates pod with Patroni settings for an instance.
func instanceEnvVars(
	cluster *v1alpha1.PostgresCluster,
	clusterPodService *v1.Service,
	leaderService *v1.Service,
	pod *v1.PodSpec,
) error {
	var (
		patroniPort  = *cluster.Spec.Patroni.Port
		postgresPort = *cluster.Spec.Port
		podSubdomain = clusterPodService.Name
	)

	// This must match the leader Service definition, but mapping the TargetPort
	// to ContainerPort is a pain. Check our assumptions and use constants instead.
	if len(leaderService.Spec.Ports) != 1 ||
		leaderService.Spec.Ports[0].Name != naming.PortPostgreSQL ||
		leaderService.Spec.Ports[0].TargetPort.StrVal != naming.PortPostgreSQL {
		ports, _ := json.Marshal(leaderService.Spec.Ports)
		return errors.Errorf("unexpected leader service ports: %s", ports)
	}

	// ServicePort(Name, TargetPort, Protocol) â†’ EndpointPort(Name, ContainerPort, Protocol)
	ports, _ := yaml.Marshal([]v1.EndpointPort{{
		Name:     naming.PortPostgreSQL,
		Port:     postgresPort,
		Protocol: v1.ProtocolTCP,
	}})

	expected := []v1.EnvVar{
		// Set "name" to the v1.Pod's name. Required when using Kubernetes for DCS.
		// Patroni must be restarted when changing this value.
		{
			Name: "PATRONI_NAME",
			ValueFrom: &v1.EnvVarSource{FieldRef: &v1.ObjectFieldSelector{
				APIVersion: "v1",
				FieldPath:  "metadata.name",
			}},
		},

		// Set "kubernetes.pod_ip" to the v1.Pod's primary IP address.
		// Patroni must be restarted when changing this value.
		{
			Name: "PATRONI_KUBERNETES_POD_IP",
			ValueFrom: &v1.EnvVarSource{FieldRef: &v1.ObjectFieldSelector{
				APIVersion: "v1",
				FieldPath:  "status.podIP",
			}},
		},

		// When using Endpoints for DCS, Patroni needs to replicate the leader
		// ServicePort definitions. Set "kubernetes.ports" to the YAML of this
		// Pod's equivalent EndpointPort definitions.
		//
		// This is connascent with PATRONI_POSTGRESQL_CONNECT_ADDRESS below.
		// Patroni must be restarted when changing this value.
		{
			Name:  "PATRONI_KUBERNETES_PORTS",
			Value: string(ports),
		},

		// Set "postgresql.connect_address" using the Pod's stable DNS name.
		// PostgreSQL must be restarted when changing this value.
		{
			Name:  "PATRONI_POSTGRESQL_CONNECT_ADDRESS",
			Value: fmt.Sprintf("%s.%s:%d", "$(PATRONI_NAME)", podSubdomain, postgresPort),
		},

		// Set "postgresql.listen" using the special address "*" to mean all TCP
		// interfaces. When connecting locally over TCP, Patroni will use "localhost".
		//
		// This is connascent with PATRONI_POSTGRESQL_CONNECT_ADDRESS above.
		// PostgreSQL must be restarted when changing this value.
		{
			Name:  "PATRONI_POSTGRESQL_LISTEN",
			Value: fmt.Sprintf("*:%d", postgresPort),
		},

		// Set "restapi.connect_address" using the Pod's stable DNS name.
		// Patroni must be reloaded when changing this value.
		{
			Name:  "PATRONI_RESTAPI_CONNECT_ADDRESS",
			Value: fmt.Sprintf("%s.%s:%d", "$(PATRONI_NAME)", podSubdomain, patroniPort),
		},

		// Set "restapi.listen" using the special address "*" to mean all TCP interfaces.
		// This is connascent with PATRONI_RESTAPI_CONNECT_ADDRESS above.
		// Patroni must be reloaded when changing this value.
		{
			Name:  "PATRONI_RESTAPI_LISTEN",
			Value: fmt.Sprintf("*:%d", patroniPort),
		},

		// Our image tells the Patroni daemon `patroni` to look here for its
		// configuration file(s).
		// TODO(cbandy): Make this true!
		{
			Name:  "PATRONI_CONFIG_FILE",
			Value: configDirectory,
		},

		// The Patroni client `patronictl` looks here for its configuration file(s).
		{
			Name:  "PATRONICTL_CONFIG_FILE",
			Value: configDirectory,
		},
	}

	database := findOrAppendContainer(&pod.Containers, naming.ContainerDatabase)
	database.Env = mergeEnvVars(database.Env, expected...)

	return nil
}

// instanceConfigVolumeAndMount populates pod with a volume and mount of
// clusterConfigMap and instanceConfigMap.
func instanceConfigVolumeAndMount(
	_ *v1alpha1.PostgresCluster, clusterConfigMap, instanceConfigMap *v1.ConfigMap,
	pod *v1.PodSpec,
) {
	// TODO(cbandy): User config will come from the spec.
	var (
		patroniConfig []v1.VolumeProjection
	)

	volume := v1.Volume{Name: "patroni-config"}
	volume.Projected = &v1.ProjectedVolumeSource{}

	// Add our projections after those specified in the CR. Items later in the
	// list take precedence over earlier items (that is, last write wins).
	// - https://docs.openshift.com/container-platform/latest/nodes/containers/nodes-containers-projected-volumes.html
	// - https://kubernetes.io/docs/concepts/storage/volumes/#projected
	volume.Projected.Sources = append(
		patroniConfig,
		v1.VolumeProjection{
			ConfigMap: &v1.ConfigMapProjection{
				LocalObjectReference: v1.LocalObjectReference{
					Name: clusterConfigMap.Name,
				},
				Items: []v1.KeyToPath{{
					Key:  configMapFileKey,
					Path: "~postgres-operator_cluster.yaml",
				}},
			},
		},
		v1.VolumeProjection{
			ConfigMap: &v1.ConfigMapProjection{
				LocalObjectReference: v1.LocalObjectReference{
					Name: instanceConfigMap.Name,
				},
				Items: []v1.KeyToPath{{
					Key:  configMapFileKey,
					Path: "~postgres-operator_instance.yaml",
				}},
			},
		},
	)

	mount := v1.VolumeMount{
		Name:      volume.Name,
		MountPath: configDirectory,
		ReadOnly:  true,
	}

	pod.Volumes = mergeVolumes(pod.Volumes, volume)

	database := findOrAppendContainer(&pod.Containers, naming.ContainerDatabase)
	database.VolumeMounts = mergeVolumeMounts(database.VolumeMounts, mount)
}

// instanceYAML returns Patroni settings that apply to instance.
func instanceYAML(_ *v1alpha1.PostgresCluster, _ metav1.Object) (string, error) {
	root := map[string]interface{}{
		// Missing here is "name" which cannot be known until the instance Pod is
		// created. That value should be injected using the downward API and the
		// PATRONI_NAME environment variable.

		"kubernetes": map[string]interface{}{
			// Missing here is "pod_ip" which cannot be known until the instance Pod is
			// created. That value should be injected using the downward API and the
			// PATRONI_KUBERNETES_POD_IP environment variable.

			// Missing here is "ports" which is is connascent with "postgresql.connect_address".
			// See the PATRONI_KUBERNETES_PORTS env variable.
		},

		"postgresql": map[string]interface{}{
			// TODO(cbandy): "bin_dir"
			// TODO(cbandy): "config_dir" so that users cannot override.

			// Missing here is "connect_address" which cannot be known until the
			// instance Pod is created. That value should be injected using the downward
			// API and the PATRONI_POSTGRESQL_CONNECT_ADDRESS environment variable.

			// FIXME(cbandy): "data_dir"
			"data_dir": "/tmp/data_dir",

			// Missing here is "listen" which is connascent with "connect_address".
			// See the PATRONI_POSTGRESQL_LISTEN environment variable.

			// TODO(cbandy): "pgpass"

			// Prefer to use UNIX domain sockets for local connections. If the PostgreSQL
			// parameter "unix_socket_directories" is set, Patroni will connect using one
			// of those directories. Otherwise, it will use the client (libpq) default.
			"use_unix_socket": true,
		},

		"restapi": map[string]interface{}{
			// Missing here is "connect_address" which cannot be known until the
			// instance Pod is created. That value should be injected using the downward
			// API and the PATRONI_RESTAPI_CONNECT_ADDRESS environment variable.

			// Missing here is "listen" which is connascent with "connect_address".
			// See the PATRONI_RESTAPI_LISTEN environment variable.
		},

		"tags": map[string]interface{}{
			// TODO(cbandy): "nofailover"
			// TODO(cbandy): "nosync"
		},
	}

	b, err := yaml.Marshal(root)
	return string(append([]byte(yamlGeneratedWarning), b...)), err
}
