/*
 Copyright 2021 Crunchy Data Solutions, Inc.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

package patroni

import (
	"strings"
	"testing"

	"gotest.tools/v3/assert"
	appsv1 "k8s.io/api/apps/v1"
	v1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"

	"github.com/crunchydata/postgres-operator/internal/postgres"
	"github.com/crunchydata/postgres-operator/pkg/apis/postgres-operator.crunchydata.com/v1alpha1"
)

func TestClusterYAML(t *testing.T) {
	t.Parallel()

	cluster := new(v1alpha1.PostgresCluster)
	cluster.Namespace = "some-namespace"
	cluster.Name = "cluster-name"

	data, err := clusterYAML(cluster)
	assert.NilError(t, err)
	assert.Equal(t, data, strings.TrimSpace(`
# Generated by postgres-operator. DO NOT EDIT.
# Your changes will not be saved.
bootstrap:
  dcs: {}
ctl:
  cacert: /etc/patroni/~postgres-operator/patroni.ca-roots
  certfile: /etc/patroni/~postgres-operator/patroni.crt+key
  insecure: false
  keyfile: null
kubernetes:
  labels:
    postgres-operator.crunchydata.com/cluster: cluster-name
  namespace: some-namespace
  role_label: postgres-operator.crunchydata.com/role
  scope_label: postgres-operator.crunchydata.com/patroni
  use_endpoints: true
postgresql:
  authentication:
    replication:
      username: postgres
  create_replica_methods: []
restapi:
  cafile: /etc/patroni/~postgres-operator/patroni.ca-roots
  certfile: /etc/patroni/~postgres-operator/patroni.crt+key
  keyfile: null
  verify_client: required
scope: cluster-name-ha
	`)+"\n")
}

func TestDynamicConfiguration(t *testing.T) {
	t.Parallel()

	parameters := func(in map[string]string) *postgres.ParameterSet {
		out := postgres.NewParameterSet()
		for k, v := range in {
			out.Add(k, v)
		}
		return out
	}

	for _, tt := range []struct {
		name     string
		input    map[string]interface{}
		hbas     postgres.HBAs
		params   postgres.Parameters
		expected map[string]interface{}
	}{
		{
			name: "empty is valid",
			expected: map[string]interface{}{
				"postgresql": map[string]interface{}{
					"parameters":    map[string]interface{}{},
					"pg_hba":        []string{},
					"use_pg_rewind": true,
				},
			},
		},
		{
			name: "top-level passes through",
			input: map[string]interface{}{
				"loop_wait": 5,
			},
			expected: map[string]interface{}{
				"loop_wait": 5,
				"postgresql": map[string]interface{}{
					"parameters":    map[string]interface{}{},
					"pg_hba":        []string{},
					"use_pg_rewind": true,
				},
			},
		},
		{
			name: "postgresql: wrong-type is ignored",
			input: map[string]interface{}{
				"postgresql": true,
			},
			expected: map[string]interface{}{
				"postgresql": map[string]interface{}{
					"parameters":    map[string]interface{}{},
					"pg_hba":        []string{},
					"use_pg_rewind": true,
				},
			},
		},
		{
			name: "postgresql.parameters: wrong-type is ignored",
			input: map[string]interface{}{
				"postgresql": map[string]interface{}{
					"parameters": true,
				},
			},
			expected: map[string]interface{}{
				"postgresql": map[string]interface{}{
					"parameters":    map[string]interface{}{},
					"pg_hba":        []string{},
					"use_pg_rewind": true,
				},
			},
		},
		{
			name: "postgresql.parameters: input passes through",
			input: map[string]interface{}{
				"postgresql": map[string]interface{}{
					"parameters": map[string]interface{}{
						"something": "str",
						"another":   5,
					},
				},
			},
			expected: map[string]interface{}{
				"postgresql": map[string]interface{}{
					"parameters": map[string]interface{}{
						"something": "str",
						"another":   5,
					},
					"pg_hba":        []string{},
					"use_pg_rewind": true,
				},
			},
		},
		{
			name: "postgresql.parameters: input overrides default",
			input: map[string]interface{}{
				"postgresql": map[string]interface{}{
					"parameters": map[string]interface{}{
						"something": "str",
						"another":   5,
					},
				},
			},
			params: postgres.Parameters{
				Default: parameters(map[string]string{
					"something": "overridden",
					"unrelated": "default",
				}),
			},
			expected: map[string]interface{}{
				"postgresql": map[string]interface{}{
					"parameters": map[string]interface{}{
						"something": "str",
						"another":   5,
						"unrelated": "default",
					},
					"pg_hba":        []string{},
					"use_pg_rewind": true,
				},
			},
		},
		{
			name: "postgresql.parameters: mandatory overrides input",
			input: map[string]interface{}{
				"postgresql": map[string]interface{}{
					"parameters": map[string]interface{}{
						"something": "str",
						"another":   5,
					},
				},
			},
			params: postgres.Parameters{
				Mandatory: parameters(map[string]string{
					"something": "overrides",
					"unrelated": "setting",
				}),
			},
			expected: map[string]interface{}{
				"postgresql": map[string]interface{}{
					"parameters": map[string]interface{}{
						"something": "overrides",
						"another":   5,
						"unrelated": "setting",
					},
					"pg_hba":        []string{},
					"use_pg_rewind": true,
				},
			},
		},
		{
			name: "postgresql.pg_hba: wrong-type is ignored",
			input: map[string]interface{}{
				"postgresql": map[string]interface{}{
					"pg_hba": true,
				},
			},
			expected: map[string]interface{}{
				"postgresql": map[string]interface{}{
					"parameters":    map[string]interface{}{},
					"pg_hba":        []string{},
					"use_pg_rewind": true,
				},
			},
		},
		{
			name: "postgresql.pg_hba: default when no input",
			input: map[string]interface{}{
				"postgresql": map[string]interface{}{
					"pg_hba": nil,
				},
			},
			hbas: postgres.HBAs{
				Default: []postgres.HostBasedAuthentication{
					*postgres.NewHBA().Local().Method("peer"),
				},
			},
			expected: map[string]interface{}{
				"postgresql": map[string]interface{}{
					"parameters": map[string]interface{}{},
					"pg_hba": []string{
						"local all all peer",
					},
					"use_pg_rewind": true,
				},
			},
		},
		{
			name: "postgresql.pg_hba: no default when input",
			input: map[string]interface{}{
				"postgresql": map[string]interface{}{
					"pg_hba": []string{"custom"},
				},
			},
			hbas: postgres.HBAs{
				Default: []postgres.HostBasedAuthentication{
					*postgres.NewHBA().Local().Method("peer"),
				},
			},
			expected: map[string]interface{}{
				"postgresql": map[string]interface{}{
					"parameters": map[string]interface{}{},
					"pg_hba": []string{
						"custom",
					},
					"use_pg_rewind": true,
				},
			},
		},
		{
			name: "postgresql.pg_hba: mandatory before others",
			input: map[string]interface{}{
				"postgresql": map[string]interface{}{
					"pg_hba": []string{"custom"},
				},
			},
			hbas: postgres.HBAs{
				Mandatory: []postgres.HostBasedAuthentication{
					*postgres.NewHBA().Local().Method("peer"),
				},
			},
			expected: map[string]interface{}{
				"postgresql": map[string]interface{}{
					"parameters": map[string]interface{}{},
					"pg_hba": []string{
						"local all all peer",
						"custom",
					},
					"use_pg_rewind": true,
				},
			},
		},
	} {
		t.Run(tt.name, func(t *testing.T) {
			actual := DynamicConfiguration(tt.input, tt.hbas, tt.params)
			assert.DeepEqual(t, tt.expected, actual)
		})
	}
}

func TestInstanceConfigFiles(t *testing.T) {
	t.Parallel()

	cm1 := &v1.ConfigMap{ObjectMeta: metav1.ObjectMeta{Name: "cm1"}}
	cm2 := &v1.ConfigMap{ObjectMeta: metav1.ObjectMeta{Name: "cm2"}}

	projections := instanceConfigFiles(cm1, cm2)

	assert.Assert(t, marshalEquals(projections, strings.TrimSpace(`
- configMap:
    items:
    - key: patroni.yaml
      path: ~postgres-operator_cluster.yaml
    name: cm1
- configMap:
    items:
    - key: patroni.yaml
      path: ~postgres-operator_instance.yaml
    name: cm2
	`)+"\n"))
}

func TestInstanceEnvironment(t *testing.T) {
	t.Parallel()

	cluster := new(v1alpha1.PostgresCluster)
	cluster.Default()
	leaderService := new(v1.Service)
	podService := new(v1.Service)
	podService.Name = "pod-dns"

	vars := instanceEnvironment(cluster, podService, leaderService, nil)

	assert.Assert(t, marshalEquals(vars, strings.TrimSpace(`
- name: PATRONI_NAME
  valueFrom:
    fieldRef:
      apiVersion: v1
      fieldPath: metadata.name
- name: PATRONI_KUBERNETES_POD_IP
  valueFrom:
    fieldRef:
      apiVersion: v1
      fieldPath: status.podIP
- name: PATRONI_KUBERNETES_PORTS
  value: |
    []
- name: PATRONI_POSTGRESQL_CONNECT_ADDRESS
  value: $(PATRONI_NAME).pod-dns:5432
- name: PATRONI_POSTGRESQL_LISTEN
  value: '*:5432'
- name: PATRONI_RESTAPI_CONNECT_ADDRESS
  value: $(PATRONI_NAME).pod-dns:8008
- name: PATRONI_RESTAPI_LISTEN
  value: '*:8008'
- name: PATRONI_CONFIG_FILE
  value: /etc/patroni
- name: PATRONICTL_CONFIG_FILE
  value: /etc/patroni
	`)+"\n"))

	t.Run("MatchingPorts", func(t *testing.T) {
		leaderService.Spec.Ports = []v1.ServicePort{{Name: "postgres"}}
		leaderService.Spec.Ports[0].TargetPort.StrVal = "postgres"
		containers := []v1.Container{{Name: "okay"}}
		containers[0].Ports = []v1.ContainerPort{{
			Name: "postgres", ContainerPort: 9999, Protocol: v1.ProtocolTCP,
		}}

		vars := instanceEnvironment(cluster, podService, leaderService, containers)

		assert.Assert(t, marshalEquals(vars, strings.TrimSpace(`
- name: PATRONI_NAME
  valueFrom:
    fieldRef:
      apiVersion: v1
      fieldPath: metadata.name
- name: PATRONI_KUBERNETES_POD_IP
  valueFrom:
    fieldRef:
      apiVersion: v1
      fieldPath: status.podIP
- name: PATRONI_KUBERNETES_PORTS
  value: |
    - name: postgres
      port: 9999
      protocol: TCP
- name: PATRONI_POSTGRESQL_CONNECT_ADDRESS
  value: $(PATRONI_NAME).pod-dns:5432
- name: PATRONI_POSTGRESQL_LISTEN
  value: '*:5432'
- name: PATRONI_RESTAPI_CONNECT_ADDRESS
  value: $(PATRONI_NAME).pod-dns:8008
- name: PATRONI_RESTAPI_LISTEN
  value: '*:8008'
- name: PATRONI_CONFIG_FILE
  value: /etc/patroni
- name: PATRONICTL_CONFIG_FILE
  value: /etc/patroni
		`)+"\n"))
	})
}

func TestInstanceYAML(t *testing.T) {
	t.Parallel()

	cluster := new(v1alpha1.PostgresCluster)
	instance := new(appsv1.StatefulSet)

	data, err := instanceYAML(cluster, instance)
	assert.NilError(t, err)
	assert.Equal(t, data, strings.TrimSpace(`
# Generated by postgres-operator. DO NOT EDIT.
# Your changes will not be saved.
kubernetes: {}
postgresql:
  data_dir: /tmp/data_dir
  use_unix_socket: true
restapi: {}
tags: {}
	`)+"\n")
}
