<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Design on Crunchy Data PostgreSQL Operator Documentation</title>
    <link>https://crunchydata.github.io/postgres-operator/latest/gettingstarted/design/</link>
    <description>Recent content in Design on Crunchy Data PostgreSQL Operator Documentation</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	<atom:link href="https://crunchydata.github.io/postgres-operator/latest/gettingstarted/design/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Design</title>
      <link>https://crunchydata.github.io/postgres-operator/latest/gettingstarted/design/designoverview/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://crunchydata.github.io/postgres-operator/latest/gettingstarted/design/designoverview/</guid>
      <description>Provisioning So, what does the Postgres Operator actually deploy when you create a cluster?
On this diagram, objects with dashed lines are components that are optionally deployed as part of a PostgreSQL Cluster by the operator. Objects with solid lines are the fundamental and required components.
For example, within the Primary Deployment, the metrics container is completely optional. That component can be deployed using either the operator configuration or command line arguments if you want to cause metrics to be collected from the Postgres container.</description>
    </item>
    
    <item>
      <title>Custom Configuration</title>
      <link>https://crunchydata.github.io/postgres-operator/latest/gettingstarted/design/custom-config/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://crunchydata.github.io/postgres-operator/latest/gettingstarted/design/custom-config/</guid>
      <description>Custom Postgres Configurations Users and administrators can specify a custom set of Postgres configuration files be used when creating a new Postgres cluster. The configuration files you can change include -
 postgresql.conf pg_hba.conf setup.sql  Different configurations for PostgreSQL might be defined for the following -
 OLTP types of databases OLAP types of databases High Memory Minimal Configuration for Development Project Specific configurations Special Security Requirements  Global ConfigMap If you create a configMap called pgo-custom-pg-config with any of the above files within it, new clusters will use those configuration files when setting up a new database instance.</description>
    </item>
    
    <item>
      <title>Custom SSL Configuration</title>
      <link>https://crunchydata.github.io/postgres-operator/latest/gettingstarted/design/custom-config-ssl/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://crunchydata.github.io/postgres-operator/latest/gettingstarted/design/custom-config-ssl/</guid>
      <description>Custom PostgreSQL SSL Configurations The PostgreSQL Operator can create clusters that use SSL authentication by utilizing custom configmaps.
Configuration Files for SSL Authentication Users and administrators can specify a custom set of PostgreSQL configuration files to be used when creating a new PostgreSQL cluster. This example uses the files below-
 postgresql.conf pg_hba.conf pg_ident.conf  along with generated security certificates, to setup a custom SSL configuration.
Config Files Purpose The postgresql.</description>
    </item>
    
    <item>
      <title>Multi-Zone Cloud Considerations</title>
      <link>https://crunchydata.github.io/postgres-operator/latest/gettingstarted/design/multi-zone-design-considerations/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://crunchydata.github.io/postgres-operator/latest/gettingstarted/design/multi-zone-design-considerations/</guid>
      <description>Considerations for PostgreSQL Operator Deployments in Multi-Zone Cloud Environments Overview When using the PostgreSQL Operator in a Kubernetes cluster consisting of nodes that span multiple zones, special consideration must be taken to ensure all pods and the associated volumes re scheduled and provisioned within the same zone.
Given that a pod is unable mount a volume that is located in another zone, any volumes that are dynamically provisioned must be provisioned in a topology-aware manner according to the specific scheduling requirements for the pod.</description>
    </item>
    
    <item>
      <title>Rest API</title>
      <link>https://crunchydata.github.io/postgres-operator/latest/gettingstarted/design/direct-api-calls/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://crunchydata.github.io/postgres-operator/latest/gettingstarted/design/direct-api-calls/</guid>
      <description>Direct API Calls The API can also be accessed by interacting directly with the API server. This can be done by making curl calls to POST or GET information from the server. In order to make these calls you will need to provide certificates along with your request using the --cacert, --key, and --cert flags. Next you will need to provide the username and password for the RBAC along with a header that includes the content type and the --insecure flag.</description>
    </item>
    
    <item>
      <title>pgBackrest with S3</title>
      <link>https://crunchydata.github.io/postgres-operator/latest/gettingstarted/design/backrest-s3-configuration/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://crunchydata.github.io/postgres-operator/latest/gettingstarted/design/backrest-s3-configuration/</guid>
      <description>pgbackrest Configuration The PostgreSQL Operator integrates various features of the pgbackrest backup and restore project.
The pgo-backrest-repo container acts as a pgBackRest remote repository for the Postgres cluster to use for storing archive files and backups.
The following diagrams depicts some of the integration features:
In this diagram, starting from left to right we see the following:
 a user when they enter pgo backup mycluster &amp;ndash;backup-type=pgbackrest will cause a pgo-backrest container to be run as a Job, that container will execute a pgbackrest backup command in the pgBackRest repository container to perform the backup function.</description>
    </item>
    
    <item>
      <title>Eventing</title>
      <link>https://crunchydata.github.io/postgres-operator/latest/gettingstarted/design/eventing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://crunchydata.github.io/postgres-operator/latest/gettingstarted/design/eventing/</guid>
      <description>Operator Eventing The Operator creates events from the various life-cycle events going on within the Operator logic and driven by pgo users as they interact with the Operator and as Postgres clusters come and go or get updated.
Event Watching There is a pgo CLI command:
pgo watch alltopic  This command connects to the event stream and listens on a topic for event real-time. The command will not complete until the pgo user enters ctrl-C.</description>
    </item>
    
    <item>
      <title>Namespace</title>
      <link>https://crunchydata.github.io/postgres-operator/latest/gettingstarted/design/namespace/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://crunchydata.github.io/postgres-operator/latest/gettingstarted/design/namespace/</guid>
      <description>Operator Namespaces The Operator itself knows which namespace it is running within by referencing the PGO_OPERATOR_NAMESPACE environment variable at startup time from within its Deployment definition.
The PGO_OPERATOR_NAMESPACE environment variable a user sets in their .bashrc file is used to determine what namespace the Operator is deployed into. The PGO_OPERATOR_NAMESPACE variable is referenced by the Operator during deployment.
The .bashrc NAMESPACE environment variable a user sets determines which namespaces the Operator will watch.</description>
    </item>
    
    <item>
      <title>TLS</title>
      <link>https://crunchydata.github.io/postgres-operator/latest/gettingstarted/design/tls/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://crunchydata.github.io/postgres-operator/latest/gettingstarted/design/tls/</guid>
      <description>TLS Configuration Should you desire to alter the default TLS settings for the Postgres Operator, you can set the following variables in bash:
To disable TLS and make an unsecured connection on port 8080 instead of connecting securely over the default port, 8443, set:
Bash environment variables
DISABLE_TLS=true PGO_APISERVER_PORT=8080  Or inventory variables if using Ansible
pgo_disable_tls=&#39;true&#39; pgo_apiserver_port=8080  To disable TLS verifcation, set the follwing as a Bash environment variable</description>
    </item>
    
    <item>
      <title>Operator Lifecycle Management Support</title>
      <link>https://crunchydata.github.io/postgres-operator/latest/gettingstarted/design/olm/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://crunchydata.github.io/postgres-operator/latest/gettingstarted/design/olm/</guid>
      <description>Operator Lifecycle Management Support The PostgreSQL Operator supports Red Hat OLM (Operator Lifecycle Manager) to a degree starting with the PostgreSQL Operator 4.0 release.
The PostgreSQL Operator supports the different deployment models as documented here
The PostgreSQL Operator is available for download in OperatorHub.io</description>
    </item>
    
  </channel>
</rss>